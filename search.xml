<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>本地化存储技术-IndexedDB｜localForage</title>
      <link href="/2024/11/18/article1/"/>
      <url>/2024/11/18/article1/</url>
      
        <content type="html"><![CDATA[<p> <strong>前言：</strong><br>LocalStorage是浏览器存储轻量数据的一个方式，平常在本地化存储时可能会使用到，但在使用过程中会发现localStorage存在以下问题：</p><ul><li><strong>存储量小，卡顿问题</strong>： 通常限制在 5MB 左右（具体取决于浏览器），如果字符串过长，会存不下导致卡死，存储内容多会消耗内存空间</li><li><strong>存取不方便：</strong>  针对非字符串：存储需要序列化为，取值时反序列化，操作 不方便</li><li><strong>Key-value混乱</strong></li></ul><p><strong>LocalStorage 的适用场景</strong></p><ol><li>用户首选项（如暗黑模式、语言设置）</li><li>缓存简单的数据（如表单草稿）</li><li>轻量级的离线功能支持</li></ol><br/><p>对于更复杂的场景（如需要存储大量数据或支持异步操作），推荐使用 IndexedDB 或封装库 localForage：</p><h1 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h1><p>IndexedDB 是一个基于 JS 的面向对象数据库。<br>允许存储和检索用键索引的对象；可以存储结构化克隆算法支持的任何对象。</p><p> <strong>优点</strong></p><ul><li><strong>存储大</strong>：支持存储大量结构化数据</li><li><strong>灵活性</strong>：支持复杂的查询、键索引、多种数据类型等</li><li><strong>异步存取</strong>  IndexedDB 的读取和存储都是异步的，不会阻塞浏览器进程</li></ul><p><strong>缺点：</strong></p><ul><li>复杂性：使用起来相对复杂，学习成本高</li></ul><br><p>学习成本太高怎么办？<br>不慌，早就有大佬为我们封装好了，主角登场～</p><h1 id="封装IndexedDB：localForage"><a href="#封装IndexedDB：localForage" class="headerlink" title="封装IndexedDB：localForage"></a>封装IndexedDB：localForage</h1><p><strong>localForage</strong> 是一个封装库，简化了 IndexedDB 的使用，同时还提供了对其他存储机制（如 LocalStorage 和 WebSQL）的统一接口。</p><p>地址：</p><blockquote><p><a href="https://github.com/localForage/localForage">https://github.com/localForage/localForage</a></p></blockquote><p>文档：</p><blockquote><p><a href="https://localforage.github.io/localForage/">https://localforage.github.io/localForage/</a><br><a href="https://localforage.docschina.org/">https://localforage.docschina.org/</a>（中文）</p></blockquote><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><ul><li><strong>统一 API</strong>：无论底层使用 IndexedDB、LocalStorage 或 WebSQL，API 始终保持一致。</li><li><strong>自动降级</strong>：localForage 有一个优雅降级策略，若浏览器不支持 IndexedDB 或 WebSQL， 则使用localStorage。</li><li><strong>异步操作：</strong> 基于 Promise 的异步接口，避免了回调地狱。</li></ul><p>目前在所有主流浏览器中都可用：Chrome, Firefox, IE 和 Safari（包括 Safari Mobile)</p><h2 id="CRUD使用"><a href="#CRUD使用" class="headerlink" title="CRUD使用"></a>CRUD使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localforage.setItem(&quot;key&quot;, &#123; id: 1, name: &quot;item1&quot; &#125;).then((value) =&gt; &#123;</span><br><span class="line">  console.log(&quot;Stored value:&quot;, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>更多详情使用可以看文档</p></blockquote><ol><li>创建一个 indexedDB</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myIndexedDB = localforage.<span class="title function_">createInstance</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;myIndexedDB&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>存值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myIndexedDB.<span class="title function_">setItem</span>(key, value)</span><br></pre></td></tr></table></figure><ol start="3"><li>取值<br>indexedDB存取是异步的，建议使用 promise.then() 或 async&#x2F;await 去读值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myIndexedDB.<span class="title function_">getItem</span>(<span class="string">&#x27;somekey&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// we got our value</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="comment">// we got an error</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">await</span> myIndexedDB.<span class="title function_">getItem</span>(<span class="string">&#x27;somekey&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>删除某项</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myIndexedDB.<span class="title function_">removeItem</span>(<span class="string">&#x27;somekey&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="5"><li>重置数据库</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myIndexedDB.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure><h2 id="多实例"><a href="#多实例" class="headerlink" title="多实例"></a>多实例</h2><p>在有多个模块需要使用本地村粗使，可以分模块创建多个实例。<br>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eryaDB</span>: localforage.<span class="title function_">createInstance</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;eryaDB&#x27;</span>,</span><br><span class="line">&#125;),</span><br><span class="line"><span class="attr">csdnDB</span>: localforage.<span class="title function_">createInstance</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;csdnDB&#x27;</span>,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>可以分别作为一个State，在页面中分别直接调取使用</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端实现CodeDiff组件</title>
      <link href="/2024/09/11/article6/"/>
      <url>/2024/09/11/article6/</url>
      
        <content type="html"><![CDATA[<h1 id="实现效果及使用方法"><a href="#实现效果及使用方法" class="headerlink" title="实现效果及使用方法"></a>实现效果及使用方法</h1><p>最终实现效果与gitlab代码对比类似<br><img src="/img/article6/article6_show.gif" style="width: 400px"></p><p>该组件满足以下功能：</p><ol><li>展示变更行的代码：展示变更行，未变更的地方会根据需求折叠（超过10行折叠）。</li><li>显示一致的代码： 对于两段代码完全一致的情况，展示时不会加上任何标记或样式，比如加色、删除等，代码行完全按照原样显示，而不是仅仅显示空的diff。</li></ol><p><b>使用方式：</b></p><ul><li>oldString {string} 变更前内容</li><li>newString {string} 变更后内容</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">CodeDiff</span></span><br><span class="line">  oldString=&#123;oldString || <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">  newString=&#123;newString || <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><img src="/img/article6/article6_case.png" style="width: 600px"><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><h2 id="使用-unidiff-获取差异"><a href="#使用-unidiff-获取差异" class="headerlink" title="使用 unidiff 获取差异"></a>使用 unidiff 获取差异</h2><blockquote><p>unidiff库 基于 公共库<a href="https://www.npmjs.com/package/diff">diff</a>（算法基于<a href="http://www.xmailserver.org/diff2.pdf">An O(ND) Difference Algorithm and Its Variations∗</a>） 。用于文本差异计算，基于Myers算法，能够对字符串进行diff操作，返回变更对象的列表，并且支持生成统一格式的输出。</p></blockquote><p>使用<a href="https://www.npmjs.com/package/unidiff">unidiff</a>库来计算两个字符串的差异，返回差异结果<code>diffLines()</code></p><h2 id="差异结果展示"><a href="#差异结果展示" class="headerlink" title="差异结果展示"></a>差异结果展示</h2><blockquote><p>react-diff-view库： 类似Git差异比较的展示，能够将生成的diff展示成React组件。<br>“react-diff-view” vs “react-diff-viewer”<br>  都可以以满足对比的需求（仅展示）<br>  前者可拓展性强，后续可拓展评论等功能…<br>  但后者由于高度封装，无法高度定制化需求（例如当两边完全一致也展示就无法实现）。</p></blockquote><p>将计算结果处理成<a href="https://www.npmjs.com/package/react-diff-view">react-diff-view</a>能支持的格式进行展示。</p><h3 id="a-检查一致性"><a href="#a-检查一致性" class="headerlink" title="a.检查一致性"></a>a.检查一致性</h3><p>如果 <code>diffLines()</code> 返回空数组（即两段代码一致），按照unidiff生成的模板格式构造一个diff输出，这样即使没有差异，也能展示出所有代码行。</p><h3 id="b-折叠未变更行"><a href="#b-折叠未变更行" class="headerlink" title="b.折叠未变更行"></a>b.折叠未变更行</h3><p>在生成的diff展示组件中，如果未变更的行超过10行，可以利用 <code>react-diff-view</code> 提供的折叠功能（或自定义逻辑）进行折叠显示。</p><h1 id="库相关方法"><a href="#库相关方法" class="headerlink" title="库相关方法"></a>库相关方法</h1><p>仅列举unidiff和react-diff-view使用到的一些关键方法，详细请移步官网<br><img src='/img/article6/article6_npm.jpg' ></p><h1 id="代码实现及解析"><a href="#代码实现及解析" class="headerlink" title="代码实现及解析"></a>代码实现及解析</h1><p>tips：省略样式部分，非完整代码，关注主要逻辑！</p><h2 id="主组件"><a href="#主组件" class="headerlink" title="主组件"></a>主组件</h2><p>目的：接收新旧string和title，unidiff 计算差异(<code>diffLines</code>)+格式化(<code>formatLines</code>)，传递给 <code>DiffCode</code> 组件进行渲染。</p><div class="note primary simple"><p>以上述case举例，diffLines实际传入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">diffLines(</span><br><span class="line">  <span class="string">&quot;test1\n第一行\n不一样啦————\nbonjour\nje suis coucou\n&quot;</span>,</span><br><span class="line">  <span class="string">&quot;newString&quot;</span>: <span class="string">&quot;test1\n第一行\n不一样啦————\nhello\ni am coucou&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>diffLines输出结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test1\n第一行\n不一样啦————\n&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;removed&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bonjour\nje suis coucou\n&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;added&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello\ni am coucou&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>再对结果进行formatLines：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--- a</span><br><span class="line">+++ b</span><br><span class="line">@@ <span class="number">-1</span><span class="punctuation">,</span><span class="number">5</span> +<span class="number">1</span><span class="punctuation">,</span><span class="number">5</span> @@</span><br><span class="line"> test1</span><br><span class="line"> 第一行</span><br><span class="line"> 不一样啦————</span><br><span class="line">-bonjour</span><br><span class="line">-je suis coucou</span><br><span class="line">+hello</span><br><span class="line">+i am coucou </span><br></pre></td></tr></table></figure></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; formatLines, diffLines &#125; <span class="keyword">from</span> <span class="string">&#x27;unidiff&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; parseDiff &#125; <span class="keyword">from</span> <span class="string">&#x27;react-diff-view&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="title function_">default</span> (&#123; oldString, newString &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> diffText = <span class="title function_">useMemo</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">formatLines</span>(<span class="title function_">diffLines</span>(oldString, newString), &#123; <span class="attr">context</span>: <span class="number">5</span> &#125;),</span><br><span class="line">    [oldString, newString],</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> [file] = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">parseDiff</span>(diffText), [diffText])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;file?.hunks?.length &gt; 0 ? (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">DiffCode</span> <span class="attr">file</span>=<span class="string">&#123;file&#125;</span> <span class="attr">oldString</span>=<span class="string">&#123;oldString&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      ) : (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>本次暂无变更<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DiffCode-组件"><a href="#DiffCode-组件" class="headerlink" title="DiffCode 组件"></a>DiffCode 组件</h2><p><b>目的：</b><br>传递处理后的 hunks， 并在 react-diff-view提供的 Diff 组件展示。</p><ul><li><code>renderHunk</code> 函数：负责渲染每一个 hunk（差异块），分3part： hunk本行，该hunk前部，该hunk尾部，前后部控制差异块的折叠和展开。</li><li><code>UnfoldCollapsed</code> 自定义组件：这是折叠&#x2F;展开的控制器组件，提供交互体验，允许用户根据需要展开或折叠变更部分。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Diff</span>, <span class="title class_">Hunk</span>, useSourceExpansion, useMinCollapsedLines &#125; <span class="keyword">from</span> <span class="string">&#x27;react-diff-view&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useEnhance <span class="keyword">from</span> <span class="string">&#x27;./useEnhance&#x27;</span></span><br><span class="line"><span class="keyword">import</span> getHunks <span class="keyword">from</span> <span class="string">&#x27;./getHunks&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">DiffCode</span> = (<span class="params">&#123; file, oldString &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> realhunks = <span class="title function_">getHunks</span>(file, oldString)</span><br><span class="line">  <span class="keyword">const</span> &#123; expandRange, hunks &#125; = <span class="title function_">useEnhance</span>(realhunks, oldString)</span><br><span class="line">  <span class="keyword">const</span> linesCount = oldString ? oldString.<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>).<span class="property">length</span> : <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">renderHunk</span> = (<span class="params">children, hunk, i, hunks</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 该hunk前折叠块/无内容</span></span><br><span class="line">    <span class="keyword">const</span> previousDecorationElement = ...</span><br><span class="line">    children.<span class="title function_">push</span>(previousDecorationElement)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hunkElement = <span class="language-xml"><span class="tag">&lt;<span class="name">Hunk</span> <span class="attr">key</span>=<span class="string">&#123;</span>`<span class="attr">hunk-</span>$&#123;<span class="attr">hunk.content</span>&#125;`&#125; <span class="attr">hunk</span>=<span class="string">&#123;hunk&#125;</span> /&gt;</span></span></span><br><span class="line">    children.<span class="title function_">push</span>(hunkElement)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i === hunks.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 该hunk后折叠块/无内容</span></span><br><span class="line">      children.<span class="title function_">push</span>(unfoldTailElement)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> children</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Diff</span> <span class="attr">viewType</span>=<span class="string">&quot;split&quot;</span> <span class="attr">diffType</span>=<span class="string">&#123;file.type&#125;</span> <span class="attr">hunks</span>=<span class="string">&#123;hunks&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;</span></span><br><span class="line"><span class="language-xml">        hunks =&gt; hunks.reduce(renderHunk, [])</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Diff</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getHunks"><a href="#getHunks" class="headerlink" title="getHunks"></a>getHunks</h3><div class="note primary modern"><p><b>hunks 的结构和内容</b><br><code>parseDiff</code>生成的差异数组：<code>hunks</code>，其中每个元素代表一个差异块（hunk），每个差异块 (hunk) 包含了一组变更行（changes）。<br>hunk 的数据结构通常是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const hunk = <span class="punctuation">&#123;</span></span><br><span class="line">  changes<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      content<span class="punctuation">:</span> &#x27;code line&#x27;<span class="punctuation">,</span></span><br><span class="line">      isNormal<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 正常行，不是变更</span></span><br><span class="line">      newLineNumber<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      oldLineNumber<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      type<span class="punctuation">:</span> &#x27;normal&#x27;<span class="punctuation">,</span> <span class="comment">// &#x27;normal&#x27; 表示没有变动，&#x27;add&#x27; 表示新增，&#x27;del&#x27; 表示删除</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  newLines<span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 变更的行数</span></span><br><span class="line">  oldLines<span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 旧的代码行数</span></span><br><span class="line">  newStart<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span>  <span class="comment">// 新文件中开始的行号</span></span><br><span class="line">  oldStart<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span>  <span class="comment">// 旧文件中开始的行号</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getHunks</span> = (<span class="params">file, oldString</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> realhunks = []</span><br><span class="line">  <span class="keyword">const</span> hunks = file?.<span class="property">hunks</span> || []</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (hunks.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 略：当完全没有diff时，手工构造一个hunks 以支持左右展示</span></span><br><span class="line">    <span class="keyword">const</span> changes = ....</span><br><span class="line">    realhunks = [</span><br><span class="line">      &#123;</span><br><span class="line">        changes,</span><br><span class="line">        <span class="attr">content</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">isPlain</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">newLines</span>: linesCount,</span><br><span class="line">        <span class="attr">oldLines</span>: linesCount,</span><br><span class="line">        <span class="attr">newStart</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">oldStart</span>: <span class="number">1</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    realhunks = hunks</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> realhunks</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useEnhance"><a href="#useEnhance" class="headerlink" title="useEnhance"></a>useEnhance</h3><ul><li>useSourceExpansion：这是一个自定义的hook，用于支持折叠和展开的行为，返回的是已扩展的 hunks 和一个控制展开的函数 expandRange。</li><li>useMinCollapsedLines：用于控制最小折叠行数（例如5行），对折叠的 hunks 进行进一步处理。</li></ul><p>通过组合这两个自定义hook，增强了差异展示的交互体验，使用户能够在差异很多时保持清晰的视图。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useSourceExpansion, useMinCollapsedLines &#125; <span class="keyword">from</span> <span class="string">&#x27;react-diff-view&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useEnhance</span> = (<span class="params">hunks, oldSource</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [hunksWithSourceExpanded, expandRange] = <span class="title function_">useSourceExpansion</span>(hunks, oldSource)</span><br><span class="line">  <span class="keyword">const</span> hunksWithMinLinesCollapsed = <span class="title function_">useMinCollapsedLines</span>(<span class="number">5</span>, hunksWithSourceExpanded, oldSource)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    expandRange,</span><br><span class="line">    <span class="attr">hunks</span>: hunksWithMinLinesCollapsed,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Diff: 可删减、有顺序的对象数组</title>
      <link href="/2024/08/03/article7/"/>
      <url>/2024/08/03/article7/</url>
      
        <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>对象数组，<br>一个对象数组，字段有顺序，可以在任意行进行增删的场景在日常业务中非常常见。<br>其特点是：</p><ul><li>有序</li><li>可以在任何位置增删</li><li>key可能变，也可能不变<ul><li>强key(key不变)的场景例如：可以拖动顺序的文件目录，key是目录或者文件的id，可以任意修改名称或者拖动顺序。</li><li>弱key(key可变)的场景例如：在页面创建一张表，字段是key，但字段名称可以修改，字段本身有顺序，可以在任意位置进行增改</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>antd实现table+form多层级字段的拖拽、新增和删除</title>
      <link href="/2024/06/29/article5/"/>
      <url>/2024/06/29/article5/</url>
      
        <content type="html"><![CDATA[<h1 id="最终实现效果"><a href="#最终实现效果" class="headerlink" title="最终实现效果"></a>最终实现效果</h1><ul><li>index需要根据层级关系展示，如1，1.1, 2…</li><li>对于任意字段类型支持新增平级字段，对于嵌套类型支持新增子字段</li><li>支持删除，对于嵌套类型，删除父字段，子字段全部删除，</li></ul><img src="/img/article5/article5-1.jpg" style="width: 100%;"><ul><li>对于嵌套类型，可以点击左侧”+&#x2F;-“收起子字段</li><li>可拖拽，拖拽完成后会重新更新index展示，对于嵌套类型会将所有子字段一起拖拽过去</li></ul><img src="/img/article5/article5-2.gif" style="width: 100%;"><h2 id="step1-table树形数据展示"><a href="#step1-table树形数据展示" class="headerlink" title="step1 table树形数据展示"></a>step1 table树形数据展示</h2><p><a href="https://ant-design.antgroup.com/components/table-cn#table-demo-tree-data">antd-树形数据table</a></p><blockquote><p>antd官网：表格支持树形数据的展示，当数据中有 <code>children</code> 字段时会自动展示为树形表格，可以展开收起子字段</p><img src="/img/article5/article5-3.jpg" style="width: 100%;"></blockquote><h2 id="step2-构造数据结构"><a href="#step2-构造数据结构" class="headerlink" title="step2 构造数据结构"></a>step2 构造数据结构</h2><h3 id="嵌套结构"><a href="#嵌套结构" class="headerlink" title="嵌套结构"></a>嵌套结构</h3><p>所以我们需要构造一个带有children的嵌套对象数组。<br>以上图为例，我们的数据结构应是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">      </span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nested&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name1的子name1.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nested&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name1.1的子_name1.1.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h3 id="key的设置"><a href="#key的设置" class="headerlink" title="key的设置"></a>key的设置</h3><p>需求中支持增删操作，依赖key值来进行计算，它代表着当前行数据在整个数据中的索引位置。<br>考虑使用0, 0.0, 0.0.0的方式来设置key，这样在新增和删除时可以方便的计算出新的key值。<br>数据结构更新：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name1的子name1.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name1.1的子_name1.1.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            ...</span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h2 id="step3-实现增、删、拖拽"><a href="#step3-实现增、删、拖拽" class="headerlink" title="step3 实现增、删、拖拽"></a>step3 实现增、删、拖拽</h2><h3 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h3><h4 id="更新索引"><a href="#更新索引" class="headerlink" title="更新索引"></a>更新索引</h4><p><code>updateKey</code>:<br>递归地遍历数据结构，为每个节点生成正确的层级索引 <code>key</code>。<br>它通过递归方式处理嵌套数据，确保每个节点的 key 与它在树形结构中的位置相对应。</p><p>函数参数：<br><code>originData</code>: 原始数据，包含了需要更新的字段。这是一个数组，可能包含平级或嵌套的数据。<br><code>fatherIndex</code>: 当前数据项的父级索引。如果是最外层的数据，父级索引为空字符串 ‘’。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">updateIndexesRecursively</span> = (<span class="params">originData, fatherIndex = <span class="string">&#x27;&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> originData) &#123;</span><br><span class="line">    <span class="comment">// 如果父级索引为空，说明是最外层数据，直接设置为当前的 index，否则将父级索引和当前索引拼接</span></span><br><span class="line">    item.<span class="property">key</span> = fatherIndex === <span class="string">&#x27;&#x27;</span> ? index : <span class="string">`<span class="subst">$&#123;fatherIndex&#125;</span>.<span class="subst">$&#123;index&#125;</span>`</span></span><br><span class="line">    <span class="comment">// 如果当前项有子项，递归处理子项</span></span><br><span class="line">    <span class="keyword">if</span> (item?.<span class="property">children</span>) &#123;</span><br><span class="line">      <span class="title function_">updateIndexesRecursively</span>(item.<span class="property">children</span>, item.<span class="property">key</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    index = (<span class="title class_">Number</span>(index) + <span class="number">1</span>).<span class="title function_">toString</span>() <span class="comment">// 每次循环时索引增加</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新展开状态"><a href="#更新展开状态" class="headerlink" title="更新展开状态"></a>更新展开状态</h4><p><code>updateExpandedKeysAfterChange：</code><br>更新展开状态的 expandedKeys，并根据操作类型（新增或删除）来调整 <code>expandedKeys</code> 数组中每个键的层级。</p><ol><li>新增：将平级节点的 key 值加 1，确保新增节点的展开状态正确。</li><li>删除：删除节点时，将相关节点的展开状态从 expandedKeys 中剔除。</li><li>递归处理 expandedKeys 数组，调整每个 key 对应的层级。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">updateExpandedKeysAfterChange</span> = (<span class="params">currentKey, operationType</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> updatedExpandedKeys = <span class="title function_">cloneDeep</span>(expandedKeys) <span class="comment">// 克隆一份当前的展开状态</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 for 循环遍历 expandedKeys 数组</span></span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> updatedExpandedKeys) &#123;</span><br><span class="line">    <span class="keyword">let</span> keyParts = key.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>) <span class="comment">// 当前展开的 key</span></span><br><span class="line">    <span class="keyword">const</span> targetKeyParts = currentKey.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>) <span class="comment">// 当前操作的节点 key</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; targetKeyParts.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 如果当前层级的 key 不匹配，跳出循环</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt; targetKeyParts.<span class="property">length</span> - <span class="number">1</span> &amp;&amp; targetKeyParts[i] !== keyParts[i]) <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果是删除操作，删除匹配的节点</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        operationType === <span class="string">&#x27;remove&#x27;</span> &amp;&amp;</span><br><span class="line">        i === targetKeyParts.<span class="property">length</span> - <span class="number">1</span> &amp;&amp;</span><br><span class="line">        <span class="title class_">Number</span>(targetKeyParts[i]) === <span class="title class_">Number</span>(keyParts[i])</span><br><span class="line">      ) &#123;</span><br><span class="line">        keyParts = <span class="literal">null</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i === targetKeyParts.<span class="property">length</span> - <span class="number">1</span> &amp;&amp; <span class="title class_">Number</span>(targetKeyParts[i]) &lt; <span class="title class_">Number</span>(keyParts[i])) &#123;</span><br><span class="line">        <span class="comment">// 如果操作的是当前层级的节点，增加或减少节点的索引值</span></span><br><span class="line">        <span class="keyword">if</span> (operationType === <span class="string">&#x27;add&#x27;</span>) &#123;</span><br><span class="line">          keyParts[i] = (<span class="title class_">Number</span>(keyParts[i]) + <span class="number">1</span>).<span class="title function_">toString</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (operationType === <span class="string">&#x27;remove&#x27;</span>) &#123;</span><br><span class="line">          keyParts[i] = (<span class="title class_">Number</span>(keyParts[i]) - <span class="number">1</span>).<span class="title function_">toString</span>()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 keyParts 不是 null，说明该 key 需要保留</span></span><br><span class="line">    <span class="keyword">if</span> (keyParts) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(keyParts.<span class="title function_">join</span>(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setExpandedKeys</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新字段数据"><a href="#更新字段数据" class="headerlink" title="更新字段数据"></a>更新字段数据</h4><p><code>updateFieldData</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">updateFieldData</span> = updatedList =&gt; &#123;</span><br><span class="line">  onChange &amp;&amp; <span class="title function_">onChange</span>(updatedList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><h4 id="创建空节点"><a href="#创建空节点" class="headerlink" title="创建空节点"></a>创建空节点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的空节点对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createEmptyRow</span> = (<span class="params">key</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">key</span>: key.<span class="title function_">toString</span>(),</span><br><span class="line">  <span class="attr">name</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="新增平级字段"><a href="#新增平级字段" class="headerlink" title="新增平级字段"></a>新增平级字段</h4><p><code>addSiblingRow</code>： 递归遍历到索引位置，在索引位置处插入一组数据。</p><ul><li>如果是最外层节点，直接插入一个新节点，并调用 上述公共方法 来更新状态。</li><li>如果是嵌套节点，递归调用 <code>insertSiblingRowRecursively</code> 以处理嵌套结构。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增平级节点，参数 currentKey 为当前节点的 key</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addSiblingRow</span> = currentKey =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> clonedData = <span class="title function_">cloneDeep</span>(value) <span class="comment">// 深拷贝数据，以确保表单渲染更新</span></span><br><span class="line">  <span class="keyword">const</span> keyArray = currentKey.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是最外层节点，直接在当前索引后插入新的数据</span></span><br><span class="line">  <span class="keyword">if</span> (keyArray.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    clonedData.<span class="title function_">splice</span>(<span class="title class_">Number</span>(currentKey) + <span class="number">1</span>, <span class="number">0</span>, <span class="title function_">createEmptyRow</span>(<span class="title class_">Number</span>(currentKey) + <span class="number">1</span>))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则递归处理嵌套的平级节点</span></span><br><span class="line">    <span class="title function_">insertSiblingRowRecursively</span>(clonedData, keyArray)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">updateIndexesRecursively</span>(clonedData, <span class="string">&#x27;&#x27;</span>) <span class="comment">// // 更新索引</span></span><br><span class="line">  <span class="title function_">updateExpandedKeysAfterChange</span>(currentKey, <span class="string">&#x27;add&#x27;</span>) <span class="comment">// 更新展开状态</span></span><br><span class="line">  <span class="title function_">updateFieldData</span>(clonedData)  <span class="comment">// 更新字段数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归遍历，直到找到需要插入的位置，然后在该位置插入新节点。</span></span><br><span class="line"><span class="comment">// 参数 originData 为原始数据，keyArray 为目标节点的索引路径</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">insertSiblingRowRecursively</span> = (<span class="params">originData, keyArray</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (keyArray.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    originData.<span class="title function_">splice</span>(<span class="title class_">Number</span>(keyArray[<span class="number">0</span>]) + <span class="number">1</span>, <span class="number">0</span>, <span class="title function_">createEmptyRow</span>(<span class="title class_">Number</span>(keyArray[<span class="number">0</span>]) + <span class="number">1</span>))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> currentIndex = keyArray[<span class="number">0</span>]</span><br><span class="line">    keyArray.<span class="title function_">shift</span>()</span><br><span class="line">    <span class="title function_">insertSiblingRowRecursively</span>(originData[currentIndex].<span class="property">children</span>, keyArray)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新增子字段"><a href="#新增子字段" class="headerlink" title="新增子字段"></a>新增子字段</h4><p>遍历 <code>keyArray</code>，定位到正确的节点，然后将新子字段插入到该节点的<code>children</code> 数组中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增子节点，参数 currentKey 为当前节点的 key</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addChildrenRow</span> = currentKey =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> clonedData = <span class="title function_">cloneDeep</span>(value) <span class="comment">// 深拷贝数据，以确保表单渲染更新</span></span><br><span class="line">  <span class="title function_">setExpandedKeys</span>(<span class="function"><span class="params">prev</span> =&gt;</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>([...prev, currentKey])]) <span class="comment">// 设置父节点需要展开</span></span><br><span class="line">  <span class="title function_">addChildToNode</span>(clonedData, currentKey.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)) <span class="comment">// 递归添加子字段</span></span><br><span class="line">  <span class="title function_">updateExpandedKeysAfterChange</span>(currentKey, <span class="string">&#x27;&#x27;</span>) <span class="comment">// 更新展开状态</span></span><br><span class="line">  <span class="title function_">updateFieldData</span>(clonedData)  <span class="comment">// 更新字段数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归添加子字段，参数 originData 为原始数据，keyArray 为目标节点的索引路径</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addChildToNode</span> = (<span class="params">originData, keyArray</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果 keyArray 长度为 1，说明已经到达最底层数据</span></span><br><span class="line">  <span class="keyword">if</span> (keyArray.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> targetData = originData[keyArray[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保目标数据有 children 数组</span></span><br><span class="line">    <span class="keyword">if</span> (!targetData.<span class="property">children</span>) &#123;</span><br><span class="line">      targetData.<span class="property">children</span> = []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 children 数组中插入新的子节点</span></span><br><span class="line">    targetData.<span class="property">children</span>.<span class="title function_">push</span>(<span class="title function_">createEmptyRow</span>(<span class="string">&#x27;0&#x27;</span>)) <span class="comment">// 创建一个空白子节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> currentIndex = keyArray[<span class="number">0</span>]</span><br><span class="line">    keyArray.<span class="title function_">shift</span>() <span class="comment">// 处理下一个索引</span></span><br><span class="line">    <span class="title function_">addChildToNode</span>(originData[currentIndex].<span class="property">children</span>, keyArray)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>remove</code>：用来执行删除操作。根据 <code>keyArray</code> 的长度判断是最外层删除还是递归删除。</p><ul><li>如果是最外层节点，直接从原始数组里splice出去，</li><li>否则递归找到当前行的父级数据，将目标数据从children里面splice出去。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定key的数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">remove</span> = key =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> newList = <span class="title function_">cloneDeep</span>(value)</span><br><span class="line">  <span class="keyword">const</span> keyArray = key.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (keyArray.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    newList.<span class="title function_">splice</span>(<span class="title class_">Number</span>(keyArray[<span class="number">0</span>]), <span class="number">1</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 递归删除</span></span><br><span class="line">    <span class="title function_">removeChildRecursively</span>(newList, keyArray)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">updateIndexesRecursively</span>(newList, <span class="string">&#x27;&#x27;</span>) <span class="comment">// 每次数据修改完需要重新遍历生成索引key</span></span><br><span class="line">  <span class="title function_">updateFieldData</span>(newList)</span><br><span class="line">  <span class="title function_">updateExpandedKeysAfterChange</span>(key, <span class="string">&#x27;remove&#x27;</span>) <span class="comment">// 每次删除后需要更新展开key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归删除子节点</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">removeChildRecursively</span> = (<span class="params">originData, keyArray</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> currentIndex = <span class="title class_">Number</span>(keyArray[<span class="number">0</span>])</span><br><span class="line">  keyArray.<span class="title function_">shift</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (keyArray.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    originData.<span class="title function_">splice</span>(currentIndex, <span class="number">1</span>) <span class="comment">// 删除当前层的子节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 继续递归进入子节点</span></span><br><span class="line">    <span class="title function_">removeChildRecursively</span>(originData[currentIndex].<span class="property">children</span>, keyArray)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h3><blockquote><p>实现：<a href="https://github.com/clauderic/react-sortable-hoc">react-sortable-hoc</a> + Table，但该库已不再维护，后续推荐使用 <a href="https://github.com/clauderic/dnd-kit">dnd-kit</a><br>以下非完整代码，仅展示拖拽的重要逻辑</p></blockquote><h4 id="拖拽：onSortEnd重写"><a href="#拖拽：onSortEnd重写" class="headerlink" title="拖拽：onSortEnd重写"></a>拖拽：onSortEnd重写</h4><p> 目标：</p><ul><li>交换数组中的两项，即 oldIndex 和 newIndex 对应的展开项的顺序。</li><li>确保在交换后，展开状态也能正确更新</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">onSortEnd = <span class="function">(<span class="params">&#123; oldIndex, newIndex &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; dataSource, onChange, updateIndexesRecursively, updateExpandedKeys &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 只有拖拽位置发生变化进行处理</span></span><br><span class="line">  <span class="keyword">if</span> (oldIndex !== newIndex) &#123;</span><br><span class="line">    <span class="keyword">const</span> newData = <span class="title function_">arrayMove</span>([...dataSource], oldIndex, newIndex); <span class="comment">//// 拷贝原始数据并进行排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (updateIndexesRecursively) &#123; <span class="comment">// 更新索引</span></span><br><span class="line">      <span class="title function_">updateIndexesRecursively</span>(newData, <span class="string">&#x27;&#x27;</span>); <span class="comment">// 使用空字符串作为父索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (onChange) &#123; <span class="comment">// 通知父组件数据变化</span></span><br><span class="line">      <span class="title function_">onChange</span>(newData);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 延迟更新展开状态，确保在数据完全更新后再更新展开状态</span></span><br><span class="line">    <span class="keyword">if</span> (updateExpandedKeys) &#123;</span><br><span class="line">      <span class="title function_">updateExpandedKeys</span>(oldIndex.<span class="title function_">toString</span>(), newIndex.<span class="title function_">toString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">\</span><br></pre></td></tr></table></figure><p><code>DraggableTable</code>传入<code>props</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">updateExpandedKeys = <span class="function">(<span class="params">oldIndex, newIndex</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> currentKeys = <span class="title function_">cloneDeep</span>(expandedKeys);</span><br><span class="line">  <span class="keyword">const</span> res = []; <span class="comment">//用于存储需要交换的两项</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// push需要交换的展开行</span></span><br><span class="line">  <span class="keyword">if</span> (expandedKeys.<span class="title function_">includes</span>(oldIndex)) res.<span class="title function_">push</span>(newIndex);</span><br><span class="line">  <span class="keyword">if</span> (expandedKeys.<span class="title function_">includes</span>(newIndex)) res.<span class="title function_">push</span>(oldIndex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历并替换需要交换的行</span></span><br><span class="line">  currentKeys = currentKeys.<span class="title function_">map</span>(<span class="function"><span class="params">currentKey</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = currentKey.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentKey !== newIndex &amp;&amp; currentKey !== oldIndex) &#123;</span><br><span class="line">      <span class="comment">// 处理需要替换的行</span></span><br><span class="line">      <span class="keyword">if</span> (temp[<span class="number">0</span>] === oldIndex) &#123;</span><br><span class="line">        temp[<span class="number">0</span>] = newIndex;</span><br><span class="line">        <span class="keyword">return</span> temp.<span class="title function_">join</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[<span class="number">0</span>] === newIndex) &#123;</span><br><span class="line">        temp[<span class="number">0</span>] = oldIndex;</span><br><span class="line">        <span class="keyword">return</span> temp.<span class="title function_">join</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentKey; <span class="comment">// 其他行不做任何改变</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 直接返回需要交换的行</span></span><br><span class="line">      <span class="keyword">return</span> currentKey;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新展开状态</span></span><br><span class="line">  <span class="title function_">setExpandedKeys</span>([...res, ...currentKeys]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> antd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React hooks源码学习 —— useState</title>
      <link href="/2024/03/08/article3/"/>
      <url>/2024/03/08/article3/</url>
      
        <content type="html"><![CDATA[<p>Hooks 的使用必须要符合这条规则：确保 Hook 在<span style="color: orange">每一次渲染中都按照同样的顺序被调用。</span></p><h1 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h1><p><code>useState</code> 是 React Hooks 提供的一个 Hook，用于在函数组件中添加状态。<br>它返回一个状态变量和一个用于更新这个状态的函数。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [year, setYear] = <span class="title function_">useState</span>(<span class="number">2024</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Year is &#123;year&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          setCount(count + 1)</span></span><br><span class="line"><span class="language-xml">          setYear(year + 1)</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo效果：<br><img src="/img/article3/demo-1.jpg" ></p><div class="note green icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p><b>useState 的内部实现原理</b><br>1.初始化 ：当组件首次渲染时，useState 会接收一个初始状态值（例如 0），并将其存储在内部状态中。<br>2.状态更新 ：调用 setCount 方法时，React 会将新的状态值存储起来，并计划触发组件的重新渲染。<br>3.重新渲染 ：在重新渲染时，useState 会返回当前的状态值，而不是初始状态值。</p></div><h2 id="useState-vs-Redux"><a href="#useState-vs-Redux" class="headerlink" title="useState vs Redux"></a>useState vs Redux</h2><table><thead><tr><th>特性</th><th><code>useState</code></th><th>Redux</th></tr></thead><tbody><tr><td><strong>应用场景</strong></td><td>简单的、局部的状态管理</td><td>复杂的、全局的状态管理</td></tr><tr><td><strong>实现机制</strong></td><td>React 内置的 Hook，使用简单直接</td><td>需要额外的配置，包括 <code>store</code>、<code>reducer</code>、<code>action</code> 等</td></tr><tr><td><strong>状态管理</strong></td><td>组件内部的状态管理</td><td>全局状态管理，多个组件共享状态</td></tr><tr><td><strong>状态更新</strong></td><td>通过 <code>setState</code> 函数更新状态</td><td>通过 <code>dispatch</code> 发送 <code>action</code>，由 <code>reducer</code> 处理</td></tr><tr><td><strong>性能影响</strong></td><td>只影响当前组件及其子组件，局部更新</td><td>影响所有订阅了状态变化的组件，全局更新</td></tr><tr><td><strong>学习曲线</strong></td><td>较低，容易上手</td><td>较高，需要理解 <code>store</code>、<code>reducer</code>、<code>action</code> 等概念</td></tr><tr><td><strong>状态初始化</strong></td><td><code>useState(initialValue)</code></td><td><code>const initialState = &#123;&#125;;</code> 在 <code>reducer</code> 中定义</td></tr><tr><td><strong>状态更新方式</strong></td><td><code>setState(newState)</code></td><td><code>dispatch(&#123; type: &#39;ACTION_TYPE&#39;, payload: data &#125;)</code></td></tr><tr><td><strong>状态订阅</strong></td><td>自动订阅，状态更新时组件重新渲染</td><td>需要使用 <code>connect</code> 或 <code>useSelector</code> 订阅状态变化</td></tr></tbody></table><p>useState的实现与Redux类似，给定初始 state，通过 <code>dispatch</code> 发送 <code>action</code>，由 <code>reducer</code> 处理 state，返回新的 state，并触发组件的重新渲染。</p><h1 id="手写useState"><a href="#手写useState" class="headerlink" title="手写useState"></a>手写useState</h1><p>综上，根据useState的实现原理，可以尝试手写一个useState，步骤如下：</p><h2 id="a-外部存储状态和索引"><a href="#a-外部存储状态和索引" class="headerlink" title="a. 外部存储状态和索引"></a>a. 外部存储状态和索引</h2><p>首先，定义一个外部数组 <code>memoizedStates</code> 用于存储所有状态，以及一个外部变量 <code>index</code> 用于记录当前状态的索引。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> memoizedStates = []</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span> <span class="comment">// 记录当前state的索引</span></span><br></pre></td></tr></table></figure><h2 id="b-实现-useState-函数"><a href="#b-实现-useState-函数" class="headerlink" title="b. 实现 useState 函数"></a>b. 实现 useState 函数</h2><ul><li>初始化状态： 在 <code>memoizedStates</code> 中查找当前索引的值，如果不存在则初始化为 <code>initialValue</code></li><li>定义 <code>setState</code> 函数： 用于更新 <code>memoizedStates</code> 中的值，并触发重新渲染。</li><li>返回状态和 <code>setState</code> 函数： 返回当前状态和 <code>setState</code> 函数，并将 <code>index</code> 加1，以便下一次调用 useState 时访问下一个状态。</li></ul><div class="note warning flat"><p><code>memoizedState</code> 依赖于 Hook 的顺序调存取数据，如果在循环、条件、嵌套函数中调用 Hooks 导致 Hooks 顺序发生变化， <code>memoizedState</code> 并不会感知到！</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> memoizedStates = []</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span> <span class="comment">//记录当前state的索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useState</span> = (<span class="params">initialValue</span>) =&gt; &#123;</span><br><span class="line">  memoizedStates[index] = memoizedStates[index] || initialValue</span><br><span class="line">  <span class="keyword">const</span> currentIndex = index</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">setState</span> = (<span class="params">newState</span>) =&gt; &#123;</span><br><span class="line">    memoizedStates[currentIndex] = newState</span><br><span class="line">    index = <span class="number">0</span> <span class="comment">// 重新渲染要清理</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [memoizedStates[index++], setState] <span class="comment">// 返回当前state，索引+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="过程图解"><a href="#过程图解" class="headerlink" title="过程图解"></a>过程图解</h2><h3 id="初次渲染"><a href="#初次渲染" class="headerlink" title="初次渲染"></a>初次渲染</h3><p>每次useState执行时，都将对应的setState绑定到对应索引的位置，然后把初始值存入 <code>memoizedStates</code> 中。</p><table style="undefined;table-layout: fixed; width: 400px">  <tr>    <th colspan="3">      <div>  const [count, setCount] = useState(0)</div>         <div>const [year, setYear] = useState(2024)</div>      </th>  </tr>  <tr>    <th>index</th>    <th>setState</th>    <th>state</th>  </tr>  <tr>    <td>0</td>    <td>setCount</td>    <td>0</td>  </tr>  <tr>    <td>1</td>    <td>setYear</td>    <td>2024</td>  </tr></table><h3 id="点击按钮"><a href="#点击按钮" class="headerlink" title="点击按钮"></a>点击按钮</h3><p>按调用顺序触发 <code>setCount</code> 和 <code>setYear</code>，每个setState内部都使用 <code>currentIndex</code> 保存了对应索引，触发对应setState会改变对应的 <code>memoizedStates</code></p><table style="undefined;table-layout: fixed; width: 400px">  <tr>    <th colspan="3">      setCount(1)    </th>  </tr>  <tr>    <th colspan="3">      state[0] = 1     </th>  </tr>  <tr>    <th>index</th>    <th>setState</th>    <th>state</th>  </tr>  <tr>    <td>0</td>    <td>setCount</td>    <td>1</td>  </tr>  <tr>    <td>1</td>    <td>setYear</td>    <td>2024</td>  </tr>  <tr>    <th colspan="3">      state更新，重新渲染    </th>  </tr>  <tr>    <th colspan="3">      setYear(2021)    </th>  </tr>  <tr>    <th>index</th>    <th>setState</th>    <th>state</th>  </tr>  <tr>    <td>0</td>    <td>setCount</td>    <td>1</td>  </tr>  <tr>    <td>1</td>    <td>setYear</td>    <td>2025</td>  </tr></table><p>每次setState都会导致重新渲染，依旧是依次执行useState，但 memoizedState 中已经有了上一次的 state 值，因此初始化的值并不是传入的初始值而是上一次的值。</p><h1 id="源码学习笔记"><a href="#源码学习笔记" class="headerlink" title="源码学习笔记"></a>源码学习笔记</h1><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p><a href="https://github.com/xu-xiaoya/react/blob/main/packages/react/src/ReactHooks.js">✈️ github-ReactHooks.js</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ReactSharedInternals</span> <span class="keyword">from</span> <span class="string">&#x27;shared/ReactSharedInternals&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveDispatcher</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = <span class="title class_">ReactSharedInternals</span>.<span class="property">H</span>;</span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> useState&lt;S&gt;(<span class="attr">initialState</span>: (<span class="function">() =&gt;</span> S) | S) &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = <span class="title function_">resolveDispatcher</span>();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.<span class="title function_">useState</span>(initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resolveDispatcher()</code> 函数用于获取当前的dispatcher实例，这个实例通常是通过访问 <code>ReactSharedInternals</code> 内部的某个属性（如 <code>ReactCurrentDispatcher</code>）来获取的。<br><code>useState</code> 实际上调用的是这个 <code>dispatcher</code> 实例上的 <code>useState</code> 方法，该方法由React内部实现，用于管理组件的状态</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><a href="https://github.com/xu-xiaoya/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.js">✈️ github-ReactFiberHooks.js</a></p><!-- ## 类型定义【ReactFiberHooks.js】 中有多个定义的type (涵盖了基本实现） --><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><h4 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h4><p>在React的ReactFiberHooks.js文件中，定义了一个Hook类型，是一个<b>单向链表</b>，它代表了函数组件中每个Hook的内部表示，<code>Hook.next</code>指向下一个Hook。<br><a href="https://github.com/xu-xiaoya/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.js#L197">✈️ github-ReactFiberHooks.js - Hook</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type <span class="title class_">Hook</span> = &#123;</span><br><span class="line">  <span class="attr">memoizedState</span>: any, </span><br><span class="line"></span><br><span class="line">  <span class="attr">baseState</span>: any, <span class="comment">// 初始化 initialState， 已经每次 dispatch 之后 newState</span></span><br><span class="line">  <span class="attr">baseUpdate</span>: <span class="title class_">Update</span>&lt;any, any&gt; | <span class="literal">null</span>, <span class="comment">// 当前需要更新的 Update ，每次更新完之后，会赋值上一个 update，方便 react 在渲染错误的边缘，数据回溯</span></span><br><span class="line">  <span class="attr">queue</span>: <span class="title class_">UpdateQueue</span>&lt;any, any&gt; | <span class="literal">null</span>, <span class="comment">// UpdateQueue 通过，更新队列</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Hook</span> | <span class="literal">null</span>,  <span class="comment">// link 到下一个 hooks，通过 next 串联每个hooks</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>memoizedState：当前Hook的状态值，用于渲染组件。</li><li>baseState：Hook的初始状态或上一次更新后的状态，用于比较和触发重新渲染。</li><li>baseQueue&#x2F;queue：指向更新队列的指针，存储待处理的更新。baseQueue在更新处理期间保持不变，而queue在每次渲染时重置。</li><li>next：指向下一个Hook对象的指针，形成Hook链。</li></ul><h4 id="Update-UpdateQueue"><a href="#Update-UpdateQueue" class="headerlink" title="Update + UpdateQueue"></a>Update + UpdateQueue</h4><p>在React中，组件的状态变化通过更新对象和更新队列来管理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type <span class="title class_">Update</span>&lt;S, A&gt; = &#123;</span><br><span class="line">  <span class="attr">lane</span>: <span class="title class_">Lane</span>,</span><br><span class="line">  <span class="attr">revertLane</span>: <span class="title class_">Lane</span>,</span><br><span class="line">  <span class="attr">action</span>: A,</span><br><span class="line">  <span class="attr">hasEagerState</span>: boolean,</span><br><span class="line">  <span class="attr">eagerState</span>: S | <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Update</span>&lt;S, A&gt;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">UpdateQueue</span>&lt;S, A&gt; = &#123;</span><br><span class="line">  <span class="attr">pending</span>: <span class="title class_">Update</span>&lt;S, A&gt; | <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">lanes</span>: <span class="title class_">Lanes</span>,</span><br><span class="line">  <span class="attr">dispatch</span>: (<span class="function"><span class="params">A</span> =&gt;</span> mixed) | <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">lastRenderedReducer</span>: (<span class="function">(<span class="params">S, A</span>) =&gt;</span> S) | <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">lastRenderedState</span>: S | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>更新（Update）：当组件状态需要改变时（如调用setState），React会创建一个更新对象。这个对象包含新状态值（或计算新状态的动作）及更新所属的通道（用于并发控制）。</li><li>更新队列（UpdateQueue）：每个组件都有一个更新队列，用于存储所有待处理的更新对象。组件重新渲染时，React会遍历队列，应用更新并计算新状态。</li></ul><h4 id="Hooks挂载和更新"><a href="#Hooks挂载和更新" class="headerlink" title="Hooks挂载和更新"></a>Hooks挂载和更新</h4><p><a href="https://github.com/xu-xiaoya/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.js#L4136">✈️ github-ReactFiberHooks.js - HooksDispatcherOnMount完整代码</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnMount</span>: <span class="title class_">Dispatcher</span> = &#123;</span><br><span class="line">  readContext,</span><br><span class="line"></span><br><span class="line">  use,</span><br><span class="line">  <span class="attr">useContext</span>: readContext,</span><br><span class="line">  <span class="attr">useEffect</span>: mountEffect, <span class="comment">// 挂载阶段处理副作用</span></span><br><span class="line">  <span class="attr">useState</span>: mountState, <span class="comment">// 添加一个状态（挂载阶段）</span></span><br><span class="line">  ....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnUpdate</span>: <span class="title class_">Dispatcher</span> = &#123;</span><br><span class="line">  readContext,</span><br><span class="line"></span><br><span class="line">  use,</span><br><span class="line">  <span class="attr">useContext</span>: readContext,</span><br><span class="line">  <span class="attr">useEffect</span>: updateEffect, <span class="comment">// 更新阶段处理副作用</span></span><br><span class="line">  <span class="attr">useState</span>: updateState, <span class="comment">// 添加一个状态（更新阶段）  </span></span><br><span class="line">  ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>HooksDispatcherOnMount：组件首次渲染（挂载）时，React使用的Hooks调度器，用于初始化Hooks。</p></li><li><p>HooksDispatcherOnUpdate：组件后续更新时，React使用的Hooks调度器，用于更新Hooks的状态或副作用。</p></li></ul><p>这两个调度器确保了Hooks在组件的不同生命周期阶段能够正确地工作。</p><h3 id="首次渲染"><a href="#首次渲染" class="headerlink" title="首次渲染"></a>首次渲染</h3><h4 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h4><p><a href="https://github.com/xu-xiaoya/react/blob/main/packages/react-reconciler/src/ReactFiberBeginWork.js#L3769">✈️ github-ReactFiberBeginWork.js - beginWork</a><br>初次渲染，React Fiber从<code>beginWork()</code>开始执行，它负责处理 React 元素树的每个节点。<br>它根据节点的类型（如函数组件、类组件、原生 DOM 元素等）调用相应的处理函数，这些处理函数负责更新 Fiber 节点的状态，并确定哪些节点需要被重新渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">beginWork</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过检查current（当前Fiber节点）是否为null来判断是否首次渲染</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新标记：如果更新队列或者context发生了改变，置为true</span></span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在进入begin阶段之前，先清除更新优先级</span></span><br><span class="line">  workInProgress.<span class="property">lanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据节点的类型调用相应的处理函数</span></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数组件</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>: &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="title class_">Component</span> = workInProgress.<span class="property">type</span>;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.<span class="property">pendingProps</span>;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        disableDefaultPropsExceptForClasses ||</span><br><span class="line">        workInProgress.<span class="property">elementType</span> === <span class="title class_">Component</span></span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : <span class="title function_">resolveDefaultPropsOnNonClassComponent</span>(<span class="title class_">Component</span>, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">updateFunctionComponent</span>(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        <span class="title class_">Component</span>,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ClassComponent</span>: &#123;</span><br><span class="line">      <span class="comment">// 略</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里hooks实际调用<code>updateFunctionComponent</code>，它负责处理函数组件的更新逻辑。</p><h4 id="updateFunctionComponent"><a href="#updateFunctionComponent" class="headerlink" title="updateFunctionComponent"></a>updateFunctionComponent</h4><p><a href="https://github.com/xu-xiaoya/react/blob/main/packages/react-reconciler/src/ReactFiberBeginWork.js#L10728">✈️ github-ReactFiberBeginWork.js - updateFunctionComponent</a>更新逻辑如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateFunctionComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: <span class="literal">null</span> | Fiber, <span class="comment">// 当前Fiber节点</span></span></span><br><span class="line"><span class="params">  workInProgress: Fiber, <span class="comment">// 当前正在处理的Fiber节点</span></span></span><br><span class="line"><span class="params">  Component: any, <span class="comment">// 组件函数</span></span></span><br><span class="line"><span class="params">  nextProps: any, <span class="comment">// 新的props</span></span></span><br><span class="line"><span class="params">  renderLanes: Lanes, <span class="comment">// 渲染优先级</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> nextChildren</span><br><span class="line">  <span class="comment">// 读取上下文</span></span><br><span class="line">  <span class="title function_">prepareToReadContext</span>(workInProgress, renderExpirationTime);</span><br><span class="line"></span><br><span class="line">  nextChildren = <span class="title function_">renderWithHooks</span>(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    <span class="title class_">Component</span>,</span><br><span class="line">    nextProps,</span><br><span class="line">    context,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; !didReceiveUpdate) &#123;</span><br><span class="line">    <span class="comment">// 调用 bailoutHooks 和 bailoutOnAlreadyFinishedWork 来跳过未更新的组件</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.<span class="property">child</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染入口为renderWithHooks。</p><h4 id="renderWithHooks"><a href="#renderWithHooks" class="headerlink" title="renderWithHooks"></a>renderWithHooks</h4><p><a href="https://github.com/xu-xiaoya/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.js#L546">✈️ github-ReactFiberHooks.js - renderWithHooks</a><br><code>renderWithHooks</code> 是React内部用于处理组件渲染的函数，并在开发模式下可能触发双重渲染以检测副作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> renderWithHooks&lt;<span class="title class_">Props</span>, <span class="title class_">SecondArg</span>&gt;(</span><br><span class="line">  <span class="attr">current</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">workInProgress</span>: <span class="title class_">Fiber</span>,</span><br><span class="line">  <span class="title class_">Component</span>: <span class="function">(<span class="params">p: Props, arg: SecondArg</span>) =&gt;</span> any,</span><br><span class="line">  <span class="attr">props</span>: <span class="title class_">Props</span>,</span><br><span class="line">  <span class="attr">secondArg</span>: <span class="title class_">SecondArg</span>,</span><br><span class="line">  <span class="attr">nextRenderLanes</span>: <span class="title class_">Lanes</span>,</span><br><span class="line">): any &#123;</span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 设置Hooks分发器</span></span><br><span class="line">    <span class="title class_">ReactSharedInternals</span>.<span class="property">H</span> = current === <span class="literal">null</span> || current.<span class="property">memoizedState</span> === <span class="literal">null</span></span><br><span class="line">      ? <span class="title class_">HooksDispatcherOnMount</span></span><br><span class="line">      : <span class="title class_">HooksDispatcherOnUpdate</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 双重渲染（Strict Mode）：</span></span><br><span class="line">  <span class="comment">// 在开发模式下，如果启用了严格模式（StrictMode），则组件可能会被渲染两次。这是为了更容易地检测到副作用。</span></span><br><span class="line">  <span class="comment">// 双重渲染期间，首次渲染会调用组件函数两次（但 Hooks 的状态在第二次调用时会复用），而第二次（实际的）渲染则不会。</span></span><br><span class="line">  <span class="comment">// 这确保了像 useMemo 这样的 Hook 在依赖项相同时不会重复运行。</span></span><br><span class="line">  <span class="keyword">const</span> shouldDoubleRenderDEV =</span><br><span class="line">    __DEV__ &amp;&amp; (workInProgress.<span class="property">mode</span> &amp; <span class="title class_">StrictLegacyMode</span>) !== <span class="title class_">NoMode</span>;</span><br><span class="line"></span><br><span class="line">  shouldDoubleInvokeUserFnsInHooksDEV = shouldDoubleRenderDEV;</span><br><span class="line">  <span class="keyword">let</span> children = __DEV__</span><br><span class="line">    ? <span class="title function_">callComponentInDEV</span>(<span class="title class_">Component</span>, props, secondArg)</span><br><span class="line">    : <span class="title class_">Component</span>(props, secondArg);</span><br><span class="line">  shouldDoubleInvokeUserFnsInHooksDEV = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于指示在当前渲染阶段是否有计划进行额外的渲染更新。</span></span><br><span class="line">  <span class="keyword">if</span> (didScheduleRenderPhaseUpdateDuringThisPass) &#123;</span><br><span class="line">    children = <span class="title function_">renderWithHooksAgain</span>(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="title class_">Component</span>,</span><br><span class="line">      props,</span><br><span class="line">      secondArg,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否需要双重渲染</span></span><br><span class="line">  <span class="keyword">if</span> (shouldDoubleRenderDEV) &#123;</span><br><span class="line">    <span class="title function_">setIsStrictModeForDevtools</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      children = <span class="title function_">renderWithHooksAgain</span>(</span><br><span class="line">        workInProgress,</span><br><span class="line">        <span class="title class_">Component</span>,</span><br><span class="line">        props,</span><br><span class="line">        secondArg,</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="title function_">setIsStrictModeForDevtools</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">finishRenderingHooks</span>(current, workInProgress, <span class="title class_">Component</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个过程大致可以分为三部分：</p><ol><li>设置Hooks分发器：根据当前的开发模式和Fiber（工作单元）的状态，选择合适的Hooks分发器。</li><li>判断双重渲染需求：如果处于开发模式且启用了严格模式，则设置标志以指示需要进行双重渲染。</li><li>首次渲染并可能双重调用：调用组件函数进行首次渲染。在开发模式下，如果启用了双重渲染，则组件函数可能会被调用两次（但Hooks的状态在第二次调用时会复用）。</li><li>处理渲染阶段更新：如果在首次渲染阶段有更新发生，则重复渲染过程，直到组件状态稳定，不再产生新的渲染阶段更新。</li></ol><h5 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h5><p>renderWithHooks 函数的核心在于根据当前Fiber的状态来设置ReactCurrentDispatcher，这是React用来分发Hooks调用的机制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactSharedInternals</span>.<span class="property">H</span> =</span><br><span class="line">  current === <span class="literal">null</span> || current.<span class="property">memoizedState</span> === <span class="literal">null</span></span><br><span class="line">    ? <span class="title class_">HooksDispatcherOnMount</span></span><br><span class="line">    : <span class="title class_">HooksDispatcherOnUpdate</span>;</span><br></pre></td></tr></table></figure><ul><li>首次挂载<br>当current（即当前的Fiber节点）为空，或者current.memoizedState为空时，为首次加载;<br><code>useState</code>为<code>HooksDispatcherOnMount.useState</code>, （即<code>mountState</code>）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useState = <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span>.<span class="property">useState</span> </span><br><span class="line">         = <span class="title class_">HooksDispatcherOnMount</span>.<span class="property">useState</span> </span><br><span class="line">         = mountState</span><br></pre></td></tr></table></figure><ul><li>更新阶段<br>当组件处于更新阶段时，current不为空且current.memoizedState也不为空。<br><code>useState</code>为<code>HooksDispatcherOnUpdate.useState</code>, （即<code>updateState</code>）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useState = <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span>.<span class="property">useState</span> </span><br><span class="line">         = <span class="title class_">HooksDispatcherOnUpdate</span>.<span class="property">useState</span> </span><br><span class="line">         = updateState</span><br></pre></td></tr></table></figure><h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><h4 id="mountState"><a href="#mountState" class="headerlink" title="mountState"></a>mountState</h4><p><a href="https://github.com/xu-xiaoya/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.js#L1907">✈️ github-ReactFiberHooks.js - mountStateImpl and mountState</a><br>mountState 函数的作用是模拟 React 的 useState 钩子，通过手动方式初始化状态并创建一个用于更新该状态的 dispatch 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为方便理解，将mountStateImpl的函数内容直接加到mountState函数中了</span></span><br><span class="line"><span class="keyword">function</span> mountState&lt;S&gt;(</span><br><span class="line">  <span class="attr">initialState</span>: (<span class="function">() =&gt;</span> S) | S,</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;<span class="title class_">BasicStateAction</span>&lt;S&gt;&gt;] &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 组件挂载时生产一个hook对象</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2. 初始state绑定到hook对象上</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    initialState = <span class="title function_">initialState</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = hook.<span class="property">baseState</span> = initialState;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 创建状态队列，记录hook值的改变</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">queue</span>: <span class="title class_">UpdateQueue</span>&lt;S, <span class="title class_">BasicStateAction</span>&lt;S&gt;&gt; = &#123;</span><br><span class="line">    <span class="attr">pending</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">lanes</span>: <span class="title class_">NoLanes</span>,</span><br><span class="line">    <span class="attr">dispatch</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">lastRenderedReducer</span>: basicStateReducer,</span><br><span class="line">    <span class="attr">lastRenderedState</span>: (<span class="attr">initialState</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> queue = hook.<span class="property">queue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 创建 dispatch 函数，更改状态的方法</span></span><br><span class="line">  <span class="comment">// 通过闭包的方式，实现队列在不同函数中的共享。前提是每次用的 dispatch 函数是同一个</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dispatch</span>: <span class="title class_">Dispatch</span>&lt;<span class="title class_">BasicStateAction</span>&lt;S&gt;&gt; = (dispatchSetState.<span class="title function_">bind</span>(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    currentlyRenderingFiber,</span><br><span class="line">    queue,</span><br><span class="line">  ): any);</span><br><span class="line">  <span class="comment">// 4.1. 绑定 dispatch 到队列</span></span><br><span class="line">  queue.<span class="property">dispatch</span> = dispatch;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 返回状态和 dispatch 函数</span></span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>mountWorkInProgressHook</code>：创建hook对象</li><li><code>dispatchSetState</code>：更新状态</li></ul><h4 id="mountWorkInProgressHook"><a href="#mountWorkInProgressHook" class="headerlink" title="mountWorkInProgressHook"></a>mountWorkInProgressHook</h4><p><a href="https://github.com/xu-xiaoya/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.js#L1023">✈️ github-ReactFiberHooks.js - mountWorkInProgressHook</a><br>在组件的渲染过程中创建并初始化一个新的 hook 对象，将其链接到当前 fiber 节点的 hook 链表中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountWorkInProgressHook</span>(<span class="params"></span>): <span class="title class_">Hook</span> &#123;</span><br><span class="line">  <span class="comment">//1. 初始化一个hook</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">hook</span>: <span class="title class_">Hook</span> = &#123;</span><br><span class="line">    <span class="attr">memoizedState</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">baseState</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">queue</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">baseUpdate</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 当前正在处理的hook</span></span><br><span class="line">    <span class="comment">// 处理第一个 Hook</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    firstWorkInProgressHook = workInProgressHook = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果已经有正在处理的 hook，将当前正在处理的 hook 的next 属性指向新创建的 hook 对象</span></span><br><span class="line">    workInProgressHook = workInProgressHook.<span class="property">next</span> = hook;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dispatchSetState"><a href="#dispatchSetState" class="headerlink" title="dispatchSetState"></a>dispatchSetState</h4><p><a href="https://github.com/xu-xiaoya/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.js#L3725">✈️ github-ReactFiberHooks.js - dispatchSetStateInternal and dispatchSetState</a><br>绑定当前 fiber 和 queue 到 dispatchAction<br>函数根据当前是在渲染阶段还是非渲染阶段触发更新，以及是否有待处理的更新或是否可以提前计算状态，来决定如何处理状态更新。在并发模式下，它还需要处理与过渡相关的逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> dispatchSetState&lt;S, A&gt;(</span><br><span class="line">  <span class="attr">fiber</span>: <span class="title class_">Fiber</span>,</span><br><span class="line">  <span class="attr">queue</span>: <span class="title class_">UpdateQueue</span>&lt;S, A&gt;,</span><br><span class="line">  <span class="attr">action</span>: A,</span><br><span class="line">): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// 这个函数返回一个布尔值didScheduleUpdate，表示是否成功安排了更新</span></span><br><span class="line">  <span class="keyword">const</span> didScheduleUpdate = <span class="title function_">dispatchSetStateInternal</span>(</span><br><span class="line">    fiber,</span><br><span class="line">    queue,</span><br><span class="line">    action,</span><br><span class="line">    lane,</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 如果didScheduleUpdate为true，则开始更新计时</span></span><br><span class="line">  <span class="keyword">if</span> (didScheduleUpdate) &#123;</span><br><span class="line">    <span class="title function_">startUpdateTimerByLane</span>(lane);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在React DevTools中标记这次更新</span></span><br><span class="line">  <span class="title function_">markUpdateInDevTools</span>(fiber, lane, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatchSetStateInternal 函数，是React 内部状态更新机制的一部分，它处理 hooks 的状态更新请求。<br>函数根据当前是在渲染阶段还是非渲染阶段触发更新，以及是否有待处理的更新或是否可以提前计算状态，来决定如何处理状态更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> dispatchSetStateInternal&lt;S, A&gt;(</span><br><span class="line">  <span class="attr">fiber</span>: <span class="title class_">Fiber</span>,       </span><br><span class="line">  <span class="attr">queue</span>: <span class="title class_">UpdateQueue</span>&lt;S, A&gt;, </span><br><span class="line">  <span class="attr">action</span>: A,          </span><br><span class="line">  <span class="attr">lane</span>: <span class="title class_">Lane</span>,         </span><br><span class="line">): boolean &#123;</span><br><span class="line">  <span class="comment">// 创建一个新的更新对象</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">update</span>: <span class="title class_">Update</span>&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,              </span><br><span class="line">    <span class="attr">revertLane</span>: <span class="title class_">NoLane</span>, </span><br><span class="line">    action,           </span><br><span class="line">    <span class="attr">hasEagerState</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="attr">eagerState</span>: <span class="literal">null</span>,  </span><br><span class="line">    <span class="attr">next</span>: (<span class="attr">null</span>: any), </span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 如果是在渲染阶段触发的更新</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRenderPhaseUpdate</span>(fiber)) &#123;</span><br><span class="line">    <span class="comment">// 则将更新添加到渲染阶段的更新队列中</span></span><br><span class="line">    <span class="title function_">enqueueRenderPhaseUpdate</span>(queue, update);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则，处理非渲染阶段的更新</span></span><br><span class="line">    <span class="keyword">const</span> alternate = fiber.<span class="property">alternate</span>; <span class="comment">// 获取当前 fiber 的备用 fiber（用于并发模式）</span></span><br><span class="line">    <span class="comment">// 如果当前 fiber 和备用 fiber 都没有待处理的更新</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      fiber.<span class="property">lanes</span> === <span class="title class_">NoLanes</span> &amp;&amp;</span><br><span class="line">      (alternate === <span class="literal">null</span> || alternate.<span class="property">lanes</span> === <span class="title class_">NoLanes</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 队列为空，可以尝试提前计算下一个状态</span></span><br><span class="line">      <span class="keyword">const</span> lastRenderedReducer = queue.<span class="property">lastRenderedReducer</span>; <span class="comment">// 获取上次渲染时使用的 reducer</span></span><br><span class="line">      <span class="keyword">if</span> (lastRenderedReducer !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> prevDispatcher = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="attr">currentState</span>: S = (queue.<span class="property">lastRenderedState</span>: any); <span class="comment">// 获取当前状态</span></span><br><span class="line">          <span class="comment">// 使用上次的 reducer 和当前的动作计算下一个状态</span></span><br><span class="line">          <span class="keyword">const</span> eagerState = <span class="title function_">lastRenderedReducer</span>(currentState, action);</span><br><span class="line">          <span class="comment">// 更新对象上标记已提前计算状态，并存储计算后的状态</span></span><br><span class="line">          update.<span class="property">hasEagerState</span> = <span class="literal">true</span>;</span><br><span class="line">          update.<span class="property">eagerState</span> = eagerState;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果新状态与旧状态相同，则可以尝试直接退出更新流程</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">is</span>(eagerState, currentState)) &#123;</span><br><span class="line">            <span class="comment">// 使用特殊方法处理并发模式下的这种情况，并返回 false 表示未安排重新渲染</span></span><br><span class="line">            <span class="title function_">enqueueConcurrentHookUpdateAndEagerlyBailout</span>(fiber, queue, update);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不满足提前计算状态的条件，则正常处理更新</span></span><br><span class="line">    <span class="keyword">const</span> root = <span class="title function_">enqueueConcurrentHookUpdate</span>(fiber, queue, update, lane);</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title function_">scheduleUpdateOnFiber</span>(root, fiber, lane);</span><br><span class="line">      <span class="title function_">entangleTransitionUpdate</span>(root, queue, lane);</span><br><span class="line">      <span class="comment">// 返回 true 表示已安排重新渲染</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没有安排重新渲染，则返回 false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><code>renderWithHooks</code>中的<code>ReactCurrentDispatcher</code>部分，更新过程调用<code>updateState</code></p><h4 id="updateState"><a href="#updateState" class="headerlink" title="updateState"></a>updateState</h4><p><a href="https://github.com/xu-xiaoya/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.js#L1949">✈️ github-ReactFiberHooks.js - updateState</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateState&lt;S&gt;(</span><br><span class="line">  <span class="attr">initialState</span>: (<span class="function">() =&gt;</span> S) | S,</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;<span class="title class_">BasicStateAction</span>&lt;S&gt;&gt;] &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">updateReducer</span>(basicStateReducer, (<span class="attr">initialState</span>: any));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际调用的是 <code>updateReducer</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateReducer&lt;S, I, A&gt;(</span><br><span class="line">  <span class="attr">reducer</span>: <span class="function">(<span class="params">S, A</span>) =&gt;</span> S,</span><br><span class="line">  <span class="attr">initialArg</span>: I,</span><br><span class="line">  init?: <span class="function"><span class="params">I</span> =&gt;</span> S,</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;A&gt;] &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>(); <span class="comment">// 获取当前工作的Hook, 即 workInProgressHook</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">updateReducerImpl</span>(hook, ((<span class="attr">currentHook</span>: any): <span class="title class_">Hook</span>), reducer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="【获取当前工作Hook】updateWorkInProgressHook"><a href="#【获取当前工作Hook】updateWorkInProgressHook" class="headerlink" title="【获取当前工作Hook】updateWorkInProgressHook"></a>【获取当前工作Hook】updateWorkInProgressHook</h5><p><a href="https://github.com/xu-xiaoya/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.js#L1044">✈️ github-ReactFiberHooks.js - updateWorkInProgressHook</a><br><code>updateReducer</code>中调用了 <code>updateWorkInProgressHook</code> ，该函数返回当前工作的Hook, 即 workInProgressHook</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateWorkInProgressHook</span>(<span class="params"></span>): <span class="title class_">Hook</span> &#123;</span><br><span class="line">  <span class="comment">// 检查是否有下一个工作中的Hook</span></span><br><span class="line">  <span class="keyword">if</span> (nextWorkInProgressHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    workInProgressHook = nextWorkInProgressHook;</span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">    currentHook = nextCurrentHook;</span><br><span class="line">    nextCurrentHook = currentHook !== <span class="literal">null</span> ? currentHook.<span class="property">next</span> : <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有下一个工作中的Hook</span></span><br><span class="line">    currentHook = nextCurrentHook;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的Hook对象</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">newHook</span>: <span class="title class_">Hook</span> = &#123;</span><br><span class="line">      <span class="attr">memoizedState</span>: currentHook.<span class="property">memoizedState</span>,</span><br><span class="line"></span><br><span class="line">      <span class="attr">baseState</span>: currentHook.<span class="property">baseState</span>,</span><br><span class="line">      <span class="attr">queue</span>: currentHook.<span class="property">queue</span>,</span><br><span class="line">      <span class="attr">baseUpdate</span>: currentHook.<span class="property">baseUpdate</span>,</span><br><span class="line"></span><br><span class="line">      <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新Hook添加到工作中Hook链表中</span></span><br><span class="line">    <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      workInProgressHook = firstWorkInProgressHook = newHook;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      workInProgressHook = workInProgressHook.<span class="property">next</span> = newHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前的 currentHook</span></span><br><span class="line">    nextCurrentHook = currentHook.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回工作中的Hook</span></span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>nextWorkInProgressHook</code>存在，React将继续处理<code>workInProgressHook</code>链表中的下一个Hook。<br>如果<code>nextWorkInProgressHook</code>不存在，这通常意味着组件正在进行初始渲染，此时React会新建一个Hook并将其添加到workInProgressHook链表中。<br>在正常的重新渲染过程中，<code>nextWorkInProgressHook</code>不应该为null。</p><h5 id="updateReducerImpl"><a href="#updateReducerImpl" class="headerlink" title="updateReducerImpl"></a>updateReducerImpl</h5><p>函数返回一个数组，包含两个元素：</p><ul><li>更新后的状态（hook.memoizedState）。</li><li>一个dispatch函数，用于触发状态更新</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateReducerImpl&lt;S, A&gt;(</span><br><span class="line">  <span class="attr">hook</span>: <span class="title class_">Hook</span>, <span class="comment">// 当前正在处理的Hook对象</span></span><br><span class="line">  <span class="attr">current</span>: <span class="title class_">Hook</span>, <span class="comment">// 上一次渲染时的Hook对象</span></span><br><span class="line">  <span class="attr">reducer</span>: <span class="function">(<span class="params">S, A</span>) =&gt;</span> S, <span class="comment">// 用于处理action并返回新状态的reducer函数</span></span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;A&gt;] &#123;</span><br><span class="line">  <span class="comment">// 获取Hook的更新队列</span></span><br><span class="line">  <span class="keyword">const</span> queue = hook.<span class="property">queue</span>;</span><br><span class="line">  queue.<span class="property">lastRenderedReducer</span> = reducer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// baseQueue存储的是尚未被处理的更新</span></span><br><span class="line">  <span class="keyword">let</span> baseQueue = hook.<span class="property">baseQueue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存了当前渲染周期中新增的更新</span></span><br><span class="line">  <span class="keyword">const</span> pendingQueue = queue.<span class="property">pending</span>;</span><br><span class="line">  <span class="keyword">if</span> (pendingQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果存在待处理的更新，并且baseQueue也不为空，则将两者合并</span></span><br><span class="line">    <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> baseFirst = baseQueue.<span class="property">next</span>;</span><br><span class="line">      <span class="keyword">const</span> pendingFirst = pendingQueue.<span class="property">next</span>;</span><br><span class="line">      baseQueue.<span class="property">next</span> = pendingFirst;</span><br><span class="line">      pendingQueue.<span class="property">next</span> = baseFirst;</span><br><span class="line">    &#125;</span><br><span class="line">    current.<span class="property">baseQueue</span> = baseQueue = pendingQueue;</span><br><span class="line">    queue.<span class="property">pending</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取Hook的初始状态</span></span><br><span class="line">  <span class="keyword">const</span> baseState = hook.<span class="property">baseState</span>;</span><br><span class="line">  <span class="keyword">if</span> (baseQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果没有待处理的更新，则直接将baseState作为memoizedState</span></span><br><span class="line">    hook.<span class="property">memoizedState</span> = baseState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 如果有待处理的更新，则开始处理这些更新</span></span><br><span class="line">    <span class="keyword">const</span> first = baseQueue.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">let</span> newState = baseState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下变量用于构建新的baseQueue和baseState</span></span><br><span class="line">    <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueFirst = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">newBaseQueueLast</span>: <span class="title class_">Update</span>&lt;S, A&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> update = first;</span><br><span class="line">    <span class="keyword">let</span> didReadFromEntangledAsyncAction = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历更新队列，直到回到起点（因为队列是循环的）</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 省略了部分代码，主要处理更新的优先级、是否跳过更新等逻辑</span></span><br><span class="line">      <span class="comment">// ....</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 处理当前更新</span></span><br><span class="line">      <span class="keyword">const</span> action = update.<span class="property">action</span>;</span><br><span class="line">      <span class="comment">// 在开发模式下，可能会双次调用用户定义的函数（为了检测副作用）</span></span><br><span class="line">      <span class="keyword">if</span> (shouldDoubleInvokeUserFnsInHooksDEV) &#123;</span><br><span class="line">        <span class="title function_">reducer</span>(newState, action);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据更新是否有急切状态（eagerState），决定如何更新newState</span></span><br><span class="line">      <span class="keyword">if</span> (update.<span class="property">hasEagerState</span>) &#123;</span><br><span class="line">        newState = ((update.<span class="property">eagerState</span>: any): S);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newState = <span class="title function_">reducer</span>(newState, action);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 移动到下一个更新</span></span><br><span class="line">      update = update.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建新的baseQueue和baseState </span></span><br><span class="line">    <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">      newBaseState = newState;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newBaseQueueLast.<span class="property">next</span> = (<span class="attr">newBaseQueueFirst</span>: any);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果newState与memoizedState不同，则标记工作正在进行中，并更新memoizedState、baseState和baseQueue</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">is</span>(newState, hook.<span class="property">memoizedState</span>)) &#123;</span><br><span class="line">      <span class="title function_">markWorkInProgressReceivedUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hook.<span class="property">memoizedState</span> = newState;</span><br><span class="line">    hook.<span class="property">baseState</span> = newBaseState;</span><br><span class="line">    hook.<span class="property">baseQueue</span> = newBaseQueueLast;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新队列的lastRenderedState为最新的状态</span></span><br><span class="line">    queue.<span class="property">lastRenderedState</span> = newState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果没有待处理的更新，则清空队列的lanes</span></span><br><span class="line">  <span class="keyword">if</span> (baseQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    queue.<span class="property">lanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回更新后的状态和dispatch函数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dispatch</span>: <span class="title class_">Dispatch</span>&lt;A&gt; = (queue.<span class="property">dispatch</span>: any);</span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结useState的执行流程"><a href="#总结useState的执行流程" class="headerlink" title="总结useState的执行流程"></a>总结useState的执行流程</h2><p>初始化： 构建dispatcher函数和初始值</p><p>更新时：<br>触发dispatch时按序插入update, updateState的时候再按序触发reducer。可以说就是一个简单的redux。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现虚实线结合的折线图Echarts</title>
      <link href="/2023/07/17/article4/"/>
      <url>/2023/07/17/article4/</url>
      
        <content type="html"><![CDATA[<p>遇到实际与预测的需求时，经常会有趋势图实线与虚线结合的需求，分享一下实现关键点</p><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>堆叠折线图，区分不同数据段的实线和虚线：<br><img src="/img/article4/article4-4.jpg" alt="实现虚实线结合的折线图Echarts" width="70%"></p><h2 id="思路1-stack分割（失败）"><a href="#思路1-stack分割（失败）" class="headerlink" title="思路1: stack分割（失败）"></a>思路1: stack分割（失败）</h2><p>看到这个效果图，想到可以通过设置 <code>series</code> 中的 <code>stack</code>来实现，并使用<code>lineStyle</code> 属性来控制线条的实线或虚线样式。如name为”系列1”时，series中需要设置两个子对象，一个实线，一个虚线，并填充对应的<code>data</code>。<br>配置和效果图如下：<br><img src="/img/article4/article4-1.jpg" width="70%"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">series<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    name<span class="punctuation">:</span> &#x27;系列<span class="number">1</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">    type<span class="punctuation">:</span> &#x27;line&#x27;<span class="punctuation">,</span></span><br><span class="line">    stack<span class="punctuation">:</span> &#x27;总量&#x27;<span class="punctuation">,</span></span><br><span class="line">    data<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">120</span><span class="punctuation">,</span> <span class="number">132</span><span class="punctuation">,</span> <span class="number">101</span><span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    name<span class="punctuation">:</span> &#x27;系列<span class="number">1</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">    type<span class="punctuation">:</span> &#x27;line&#x27;<span class="punctuation">,</span></span><br><span class="line">    lineStyle<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      type<span class="punctuation">:</span> &#x27;dashed&#x27;</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    stack<span class="punctuation">:</span> &#x27;总量&#x27;<span class="punctuation">,</span></span><br><span class="line">    data<span class="punctuation">:</span> <span class="punctuation">[</span>&#x27;-&#x27;<span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">,</span> <span class="number">134</span><span class="punctuation">,</span> <span class="number">90</span><span class="punctuation">,</span> <span class="number">230</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    name<span class="punctuation">:</span> &#x27;系列<span class="number">2</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">    type<span class="punctuation">:</span> &#x27;line&#x27;<span class="punctuation">,</span></span><br><span class="line">    stack<span class="punctuation">:</span> &#x27;总量&#x27;<span class="punctuation">,</span></span><br><span class="line">    data<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">220</span><span class="punctuation">,</span> <span class="number">182</span><span class="punctuation">,</span> <span class="number">191</span><span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    name<span class="punctuation">:</span> &#x27;系列<span class="number">2</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">    type<span class="punctuation">:</span> &#x27;line&#x27;<span class="punctuation">,</span></span><br><span class="line">    lineStyle<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      type<span class="punctuation">:</span> &#x27;dashed&#x27;</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    stack<span class="punctuation">:</span> &#x27;总量&#x27;<span class="punctuation">,</span></span><br><span class="line">    data<span class="punctuation">:</span> <span class="punctuation">[</span>&#x27;-&#x27;<span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">,</span> <span class="number">234</span><span class="punctuation">,</span> <span class="number">290</span><span class="punctuation">,</span> <span class="number">330</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>虽然数据正确展示上了，但是我们会发现两段数据断节了？<br>于是，尝试把两段的data设置一个相同的值:</p><div style="display: flex;">  <div>    <img src="/img/article4/article4-2.jpg" >  </div>  <div>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  name<span class="punctuation">:</span> &#x27;系列<span class="number">1</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">  type<span class="punctuation">:</span> &#x27;line&#x27;<span class="punctuation">,</span></span><br><span class="line">  stack<span class="punctuation">:</span> &#x27;总量&#x27;<span class="punctuation">,</span></span><br><span class="line">  data<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">120</span><span class="punctuation">,</span> <span class="number">132</span><span class="punctuation">,</span> <span class="number">101</span><span class="punctuation">,</span> <span class="number">134</span><span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  name<span class="punctuation">:</span> &#x27;系列<span class="number">1</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">  type<span class="punctuation">:</span> &#x27;line&#x27;<span class="punctuation">,</span></span><br><span class="line">  lineStyle<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    type<span class="punctuation">:</span> &#x27;dashed&#x27;</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  stack<span class="punctuation">:</span> &#x27;总量&#x27;<span class="punctuation">,</span></span><br><span class="line">  data<span class="punctuation">:</span> <span class="punctuation">[</span>&#x27;-&#x27;<span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">,</span> <span class="number">134</span><span class="punctuation">,</span> <span class="number">90</span><span class="punctuation">,</span> <span class="number">230</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>  </div></div>发现堆叠图无法实现该效果，echarts内部将交点的数据重复绘制了两次。<h2 id="思路2-直接使用折线图"><a href="#思路2-直接使用折线图" class="headerlink" title="思路2: 直接使用折线图"></a>思路2: 直接使用折线图</h2><p>换个思路，如果去掉<code>stack</code>直接使用折线图呢？<br>我们发现两段数据可以连上了！</p><div style="display: flex;">  <div>    <img src="/img/article4/article4-3.jpg" >  </div>  <div>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  name<span class="punctuation">:</span> &#x27;系列<span class="number">1</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">  type<span class="punctuation">:</span> &#x27;line&#x27;<span class="punctuation">,</span></span><br><span class="line">  data<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">120</span><span class="punctuation">,</span> <span class="number">132</span><span class="punctuation">,</span> <span class="number">101</span><span class="punctuation">,</span> <span class="number">134</span><span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  name<span class="punctuation">:</span> &#x27;系列<span class="number">1</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">  type<span class="punctuation">:</span> &#x27;line&#x27;<span class="punctuation">,</span></span><br><span class="line">  lineStyle<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    type<span class="punctuation">:</span> &#x27;dashed&#x27;</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  data<span class="punctuation">:</span> <span class="punctuation">[</span>&#x27;-&#x27;<span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">,</span> &#x27;-&#x27;<span class="punctuation">,</span> <span class="number">134</span><span class="punctuation">,</span> <span class="number">90</span><span class="punctuation">,</span> <span class="number">230</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>  </div></div><p>但tooltip 提示会存在多个同名的提示，我们还需要处理过滤无效值和交叉的值，最终就大功告成啦～</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tooltip</span>: &#123;</span><br><span class="line">  <span class="attr">trigger</span>: <span class="string">&#x27;axis&#x27;</span>, <span class="comment">// 设置触发类型为坐标轴触发</span></span><br><span class="line">  <span class="title function_">formatter</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> hasMap = &#123;&#125;; <span class="comment">// 创建一个对象来记录已经处理过的系列名称和值</span></span><br><span class="line">    <span class="keyword">let</span> html = <span class="string">`<span class="subst">$&#123;params[<span class="number">0</span>].name&#125;</span>&lt;br&gt;`</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> param <span class="keyword">of</span> params) &#123;</span><br><span class="line">      <span class="comment">// 过滤无效值和重叠值</span></span><br><span class="line">      <span class="keyword">if</span> (param.<span class="property">value</span> !== <span class="string">&#x27;-&#x27;</span> &amp;&amp; !hasMap[param.<span class="property">seriesName</span>]) &#123;</span><br><span class="line">        <span class="comment">// 记录已处理的系列名称和值</span></span><br><span class="line">        hasMap[param.<span class="property">seriesName</span>] = param.<span class="property">value</span>;</span><br><span class="line">        html += <span class="string">`&lt;span style=&quot;display: block;&quot;&gt;<span class="subst">$&#123;param.seriesName&#125;</span>: <span class="subst">$&#123;param.value&#125;</span>&lt;/span&gt;`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;div style=&quot;text-align:left&quot;&gt;<span class="subst">$&#123;html&#125;</span>&lt;/div&gt;`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React报错#310复盘小结+hooks使用的场景+调用原理</title>
      <link href="/2023/06/30/article2/"/>
      <url>/2023/06/30/article2/</url>
      
        <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>apm报错：<strong>Minified React error #310</strong><br><a href="https://react.dev/errors/310?invariant=310">https://react.dev/errors/310?invariant=310</a><br><img src="/img/article2/article2-error.jpg"><br>当我们有条件地调用一个钩子或在所有钩子运行之前提前返回时，会产生”Rendered more hooks than during the previous render”错误。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><div style="display: flex;">  <div style="width: 49%;">    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误代码</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    …………</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (条件) &#123;</span><br><span class="line">      <span class="keyword">return</span> (……)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">-   <span class="keyword">const</span> [loading, setLoading] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">-   <span class="title function_">useEffect</span>(函数<span class="number">1</span>, [……])</span><br><span class="line">    <span class="keyword">return</span> (……)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </div>  <span style="width: 2%;"></span>  <div style="width: 49%;">    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确代码</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    …………</span><br><span class="line">+   <span class="keyword">const</span> [loading, setLoading] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">+   <span class="title function_">useEffect</span>(函数<span class="number">1</span>, [……])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (条件) &#123;</span><br><span class="line">      <span class="keyword">return</span> (……)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> (……)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </div></div><p>if中 <code>return</code>  阻塞了后续hook的渲染，为了解决该错误，将所有的钩子<b>移到函数组件的顶层</b>，以及不要在条件中使用钩子。</p><h2 id="原理-学习"><a href="#原理-学习" class="headerlink" title="原理&amp;学习"></a>原理&amp;学习</h2><p>React 依赖于 <strong>Hook 调用的顺序</strong>。<br>在正常的程序中，Hook 的调用顺序在每次渲染中都是相同的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [loading, setLoading] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="title function_">useEffect</span>(函数<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> [test, setTest] = <span class="title function_">useState</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首次渲染</span></span><br><span class="line"><span class="title function_">useState</span>(<span class="string">&#x27;false&#x27;</span>)            <span class="comment">// 1. 使用 false 初始化变量名为 loading 的 state</span></span><br><span class="line"><span class="title function_">useEffect</span>(函数<span class="number">1</span>)             <span class="comment">// 2. 添加 effect 以保存 form 操作</span></span><br><span class="line"><span class="title function_">useState</span>(<span class="string">&#x27;name&#x27;</span>)            <span class="comment">// 3. 使用 &#x27;Poppins&#x27; 初始化变量名为 surname 的 state</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二次渲染</span></span><br><span class="line"><span class="title function_">useState</span>(<span class="string">&#x27;false&#x27;</span>)            <span class="comment">// 1. 读取变量名为 loading 的 state（参数被忽略）</span></span><br><span class="line"><span class="title function_">useEffect</span>(函数<span class="number">1</span>)             <span class="comment">// 2. 替换保存 form 的 effect</span></span><br><span class="line"><span class="title function_">useState</span>(<span class="string">&#x27;name&#x27;</span>)            <span class="comment">// 3. 读取变量名为 surname 的 state（参数被忽略）</span></span><br></pre></td></tr></table></figure><p><span style="color: red;">只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联。</span></p><p>那如果在正常程序中插入一个if语句呢？如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [loading, setLoading] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="title function_">useEffect</span>(函数<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (条件) &#123;</span><br><span class="line">      <span class="keyword">return</span> （）</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> [test, setTest] = <span class="title function_">useState</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If条件的存在导致程序提前终止，不再执行下方语句（而下方又存在一些hook），导致两种渲染情况不一致：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入if没return</span></span><br><span class="line"><span class="title function_">useState</span>(<span class="string">&#x27;false&#x27;</span>)            <span class="comment">// 1. 使用 false 初始化变量名为 loading 的 state</span></span><br><span class="line"><span class="title function_">useEffect</span>(函数<span class="number">1</span>)             <span class="comment">// 2. 添加 effect 以保存 form 操作</span></span><br><span class="line"><span class="title function_">useState</span>(<span class="string">&#x27;name&#x27;</span>)            <span class="comment">// 3. 使用 &#x27;Poppins&#x27; 初始化变量名为 surname 的 state</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入if并return</span></span><br><span class="line"><span class="title function_">useState</span>(<span class="string">&#x27;false&#x27;</span>)             <span class="comment">// 1. 读取变量名为 loading 的 state（参数被忽略）</span></span><br><span class="line"><span class="title function_">useEffect</span>(函数<span class="number">1</span>)              <span class="comment">// 2. 替换保存 form 的 effect</span></span><br><span class="line"><span class="comment">//useState(&#x27;name&#x27;)           // 3. 此 Hook 被忽略！</span></span><br></pre></td></tr></table></figure><h2 id="引发错误情况"><a href="#引发错误情况" class="headerlink" title="引发错误情况"></a>引发错误情况</h2><p><a href="https://zh-hans.reactjs.org/docs/hooks-rules.html">https://zh-hans.reactjs.org/docs/hooks-rules.html</a></p><h3 id="1-不要在循环，条件或嵌套函数中调用-Hook"><a href="#1-不要在循环，条件或嵌套函数中调用-Hook" class="headerlink" title="1. 不要在循环，条件或嵌套函数中调用 Hook"></a>1. 不要在循环，条件或嵌套函数中调用 Hook</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [counter, setCounter] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">-  <span class="keyword">if</span> (counter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">-    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">-      <span class="variable language_">console</span>.<span class="title function_">log</span>(counter);</span><br><span class="line">-    &#125;);</span><br><span class="line">-  &#125;</span><br><span class="line"><span class="comment">// 将if条件语句移到useEffect钩子内部</span></span><br><span class="line">+  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">+    <span class="keyword">if</span> (counter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">+      <span class="variable language_">console</span>.<span class="title function_">log</span>(counter);</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-把所有的钩子移到组件的顶层，在任何可能返回值的条件之上。"><a href="#2-把所有的钩子移到组件的顶层，在任何可能返回值的条件之上。" class="headerlink" title="2. 把所有的钩子移到组件的顶层，在任何可能返回值的条件之上。"></a>2. 把所有的钩子移到组件的顶层，在任何可能返回值的条件之上。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [counter, setCounter] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">+ <span class="keyword">const</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&#x27;salmon&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (counter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Returning early<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Error: 该hook在counter&lt;=0条件时，才被调用</span></span><br><span class="line">- <span class="keyword">const</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&#x27;salmon&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCounter(counter + 1)&#125;&gt;toggle loading<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-React函数组件或自定义钩子中只在调用Hook"><a href="#3-React函数组件或自定义钩子中只在调用Hook" class="headerlink" title="3. React函数组件或自定义钩子中只在调用Hook"></a>3. React函数组件或自定义钩子中只在调用Hook</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在普通函数中不要使用hook</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">AppContent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [counter, setCounter] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    …………</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">App</span> = &#123;</span><br><span class="line">  <span class="attr">dataIndex</span>: <span class="string">&#x27;app&#x27;</span>,</span><br><span class="line">- <span class="attr">render</span>: <span class="title class_">AppContent</span>,</span><br><span class="line">+ <span class="attr">render</span>: <span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">AppContent</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>只从React函数组件或自定义钩子中调用Hook</li><li>只在最顶层使用 Hook</li><li>不要在循环，条件或嵌套函数中调用 Hook</li><li>确保总是在你的 React 函数的最顶层以及任何 return 之前使用 Hook</li></ul><p>这有助于React在多个<code>useState</code>和<code>useEffect</code>调用之间保留钩子的状态。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
